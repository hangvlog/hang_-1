[24届秋招内推全汇总_互联网-科技-国央企-游戏-快消-金融 (qq.com)](https://docs.qq.com/sheet/DQ3haZXRvcUNTTlVY?tab=BB08J2&scode=&_t=1691978219767&u=ca111664406f47d7b052d07a7681b72f)

根据个人简历定制面试可能遇到的问题

> 前段面试题目部分[「2021」高频前端面试题汇总之CSS篇 - 掘金 (juejin.cn)](https://juejin.cn/post/6905539198107942919#heading-29)
>
> [2022高频前端面试题——CSS篇 - 掘金 (juejin.cn)](https://juejin.cn/post/7098689890933538853#heading-3)
>
> [2023高频前端面试题合集之Vue（上篇） - 掘金 (juejin.cn)](https://juejin.cn/post/7208005892313579576#heading-10)

[金九银十，带你复盘大厂常问的项目难点 - 掘金 (juejin.cn)](https://juejin.cn/post/7274883755478564922#heading-1)

[木易杨前端进阶 (muyiy.cn)](https://muyiy.cn/)

两个系列

vue面试题[30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度） - 掘金 (juejin.cn)](https://juejin.cn/post/6844903918753808398#heading-1)

> 手撕部分
>
> [2w字 | 28道 LeetCode 题目带你看看链表的那些套路 - 掘金 (juejin.cn)](https://juejin.cn/post/6943787446505046046)

某人面试总结[2017互联网一线大厂面试总结 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903490976743438?from=search-suggest#heading-22)

# Webpack相关

ast如何构建？

Plugin` 直译为插件，基于事件流框架 `Tapable，这个事件流框架 `Tapable是什么？

某个公司的笔试：文件改变，chunk是否一定会改变哪些

## webpack能做什么，工作流程



### webpack的工作流程

webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

1. `初始化参数：`  从配置文件和shell 语句中读取与合并参数，得到最终的参数。
2. `开始编译：`  用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行 compiler 对象的 run 方法开始执行编译。
3. `确定入口：` 根据配置中的 entry 找出所有的入口文件。
4. `编译模块：` 从入口文件出发，调用所有配置的 Loader 对模块进行编译，找出该模块依赖的模块，再递归本步骤直到所有依赖文件都经过本步骤的处理。
5. 完成模块编译： 在经过第 4 步使用 Loader 编译完所有模块之后，得到每个模块被编译后的最终内容以及它们之间的依赖关系。
6. `输出资源：` 根据入口和模块之间的关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。
7. `输出完成：` 在确定输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

### babel的工作原理

解析：将代码转换成 AST

- 词法分析：将代码(字符串)分割为token流，即语法单元成的数组
- 语法分析：分析token流(上面生成的数组)并生成 AST

转换：访问 AST 的节点进行变换操作生产新的 AST

- [Taro](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FNervJS%2Ftaro%2Fblob%2Fmaster%2Fpackages%2Ftaro-transformer-wx%2Fsrc%2Findex.ts%23L15)就是利用 babel 完成的小程序语法转换

生成：以新的 AST 为基础生成代码

### webpack的运行周期包括哪些？

> `beforeRun`：Webpack 进入编译前的阶段，此时会初始化 Compiler 对象。
>
> `run`：Webpack 开始编译前的阶段，此时会读取入口文件和依赖，并创建依赖图。
>
> `compilation`：Webpack 进入编译阶段，此时会开始编译入口文件和依赖的模块，并生成输出文件。
>
> - make🛠：在钩子的回调中有开始读取 webpack 配置文件的逻辑
> - emit🏹：在钩子的回调中执行生成文件（也就是 bundle）的逻辑
> - done🔚：文件已写入文件系统后触发这个钩子
>
> `emit`：Webpack 生成输出文件前的阶段，此时可以在插件中处理生成的输出文件。
>
> `done`：Webpack 完成打包后的阶段，此时可以在插件中进行一些清理工作。

<img src="https://s1.vika.cn/space/2023/09/19/a2324094cca14010b3cdce9fb542d50e" alt="image-20230919101842932" style="zoom:40%;" />

![image-20230919102228065](https://s1.vika.cn/space/2023/09/19/f68ca16c7572474984c32149471c9e0d)

根据配置中的 entry 找出所有的入口文件，从 entry 开始，使用到 loader 先完成模块转换，然后解析形成 AST，接着遍历 AST 把所有 require 找出来形成 依赖树。递归遍历依赖树节点对应的文件，做相同的模块转换、形成依赖树的处理，直到递归结束。这样就形成了一个 chunk 初始态对象。 如果遇到动态的 import，那么就和上面对 entry 的处理一样，最后形成另一个或多个独立的 chunk 初始态对象。

### loader和plugin区别？

|                  | loader                                                       | plugin                                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 功能             | 官方解释：webpack 自带的功能只能处理 javaScript 和 JSON 文件，loader 让 webpack 能够去处理其他类型的文件，并将它们转换成有效的模块，以及被添加到依赖图中<br />浏览器中不能直接运行的代码转换成浏览器中可以直接运行的代码。<br />有了loader就能把其他所有的文件转换成js文件,那么就能通过webpack对所有的文件进行解析。也**就是loader给webpack提供了加载非js文件的能力**<br />其实loader就是操作ast语法树就行修改完成对应功能 | 官方：插件可以执行范围更广的任务，包括打包优化，资源管理，注入环境变量<br />**plugin可以扩展webpack的功能**。因为在webpack的运行周期中会广播许多的事件，plugin只需要监听这些事件，在合适的时候通过webpack提供的API对ast进行操作，就达到了目的。 |
| 什么阶段发挥作用 | 打包文件之前（loader为在模块加载时的预处理文件）             | webpack整个编译周期                                          |
| 面向的对象       | 文件加载器，操作的是文件，将文件A通过loader转换成文件B，是一个单纯的文件转化过程。 | plugin即为插件，是一个扩展器，丰富webpack本身，增强功能 ，针对的是在loader结束之后，webpack打包的整个过程，他并不直接操作文件，而是基于事件机制工作，监听webpack打包过程中的某些节点，执行广泛的任务。 |
| 用法             | test 属性，识别出哪些文件会被转换 <br />use 属性，定义出在进行转换时，应该使用哪个 loader。 | 只需要引入对应的 plugin，然后在 plugins 数组中 new 一下即可  |
| 配置             | `loader`在`module.rules`中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 `test(类型文件)`、`loader`、`options (参数)`等属性 | `plugin`在 `plugins`中单独配置，类型为数组，每一项是一个 `plugin` 的实例，参数都通过构造函数传入 |

[你真的搞懂webpack loader和plugin的区别了吗 - 掘金 (juejin.cn)](https://juejin.cn/post/7098556679242907662)



### 你知道loader的分类以及执行顺序吗？

> 影响loader执行顺序的：
>
> 1. pitch方法的返回内容
> 2. Rule.enforce的配置
> 3. 前缀 （去掉loader）
>
> - 前缀 （去掉loader）：所有普通 loader 可以通过在请求中加上 `!` 前缀来忽略（覆盖）。
> - 所有普通和前置 loader 可以通过在请求中加上 `-!` 前缀来忽略（覆盖）。
> - 所有普通，后置和前置 loader 可以通过在请求中加上 `!!` 前缀来忽略（覆盖）。

rule中配置的顺序、类型（pre，normal，post，inline）、以及loader中在pitching中返回的内容都有关

分类： inline-loader pre-loader post-loader normal-loader

布局： post-loader1 post-loader2  inline-loader1 inline-loader2 normal-loader1 normal-loader2 pre-loader1 pre-loader2

![image-20230919095638313](https://s1.vika.cn/space/2023/09/19/c131afd1b6eb44e4b814f87bdeca953f)

> 类型不同：四种loader调用先后顺序为：`pre` > `normal` > `inline` > `post` 。
>
> 类型相同：调用的优先级为，自下而上，自右向左。（pitch情况下，则反过来)。

```js
{
  module: {
    rules: [
      {
        test: /.txt$/,
        use: [
          {
            loader: getLoader("a-loader.js"),
          },
        ],
        enforce: "post",
      },
      {
        test: /.txt$/,
        use: [
          {
            loader: getLoader("b-loader.js"),
          },
          {
            loader: getLoader("c-loader.js"),
          },
        ],
        enforce: "post",
      },
    ],
  },
}
```

```
a-loader-pitch
b-loader-pitch
c-loader-pitch
c-loader 
b-loader 
a-loader 
```



### 常见的loader和plugin

CSS相关loader：

- **sass-loader**，转为css
- postcss-loader，将CSS处理，添加前缀等
- **css-loader**，加载CSS，转为js
- **style-loader**，插入到js中

js相关loader：

- babel-loader：把ES6或react转成ES5
- eslint-loader : 通过eslint检查javascript代码
- ts-loader 把 typescript 转换成 js

其他：

- file-loader
- url-loader

常见的loader：

- babel-loader 把 ES6 转换成 ES5
- ts-loader 把 typescript 转换成 js
- less-loader 把 less 转换成 css
- css-loader 对 css 样式进行处理
- style-loader 把打包的样式插入到 HTML 结构中

| loader           | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| babel-loader     | 把ES6或react转成ES5                                          |
| **css-loader**   | **加载css，支持模块化、压缩、文件导入等特性**                |
| eslint-loader    | 通过eslint检查javascript代码                                 |
| file-loader      | 把文件输出到一个文件夹中，在代码中通过相对路径来引用         |
| url-loader       | 类似file-loader，但是当文件很小的时候会把文件内容以base64方式注入到代码中 |
| **sass-loader**  | **将sass/scss文件编译成css**                                 |
| postcss-loader   | 扩展 css 语法，使用下一代 css，可以配合 autoprefixer 插件自动补齐 css3 前缀。 |
| **css-loader**   | **处理background:(url)、@import语法，让webpack能根据正确的路径进行模块化** |
| **style-loader** | **把css代码注入到javascript中，通过DOM操作区加载css**        |

常见的plugin

常用的`plugin`如下：

- `HtmlWebpackPlugin`：简化 HTML 文件创建 (依赖于 html-loader)
- `mini-css-extract-plugin`: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
- `clean-webpack-plugin`: 目录清理

![image-20230925151118036](https://s1.vika.cn/space/2023/09/25/586472931a334db0b8c172918c682866)

| 插件                                   | 功能                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| case-sensitive-paths-webpack-plugin    | 路径有误报错                                                 |
| **terser-webpack-plugin**              | **使用terser来压缩javascript**                               |
| **optimize-css-assets-webpack-plugin** | **用于优化或者压缩css资源**                                  |
| html-webpack-plugin                    | 自动生成带有入口文件引用的index.html                         |
| webpack-manifest-plugin                | 生产资产的显示清单文件                                       |
| **mini-css-extract-plugin**            | **将css提取成独立的文件，对每个包含css的js文件都会创建一个css文件，支持按需加载css和sourceMap** |
| ModuleScopePlugin                      | 引用了src目录外的文件进行报警                                |
| interpolateHtmlPlugin                  | 和htmlWebpackPlugin串行使用，允许在index.html中添加变量      |
| **ModuleNotFoundPlugin**               | **找不到模块的时候提供更详细的上下文信息**                   |
| DefinePlugin                           | 创建一个在编译时可配置的全局常量,如果你自定义了一个全局变量PRODUCTION,可在此设置其值来区分开发还是生产环境 |
| **HotModuleReplacementPlugin**         | **启用模块热替换**                                           |
| WatchMissingNodeModulesPlugin          | WatchMissingNodeModulesPlugin                                |

babel的工作流程？



[Webpack 高频面试题 - 掘金 (juejin.cn)](https://juejin.cn/post/7066807280557096974)

基础概念：

### chunk、bundle 与 moudle

![与模块的关系](https://s1.vika.cn/space/2023/09/21/658256d86d0a47198691bc6aa0bc68ac) module、chunk、bundle 这三个都可以理解为文件，区别在于：我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的是 bundle。也可以这样理解，module，chunk 和 bundle 其实就是同一份逻辑代码在不同转换场景下的三个名字。

> 一般情况下，一个chunk包括多个moudule
>
> Webpack 会将每个入口点及其依赖的模块打包为一个独立的 "chunk"，但也可以通过配置进行更细粒度的控制，例如使用动态导入（dynamic import）或代码分割（code splitting）来创建额外的 "chunk"。

### 热更新原理

[面试官：说说webpack的热更新是如何做到的？原理是什么？ | web前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/webpack/HMR.html#二、实现原理)

# Git相关

## git merge 和git rebase的区别？

相同点：

`git merge`和`git rebase`两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。

不同点：

1. `git merge`会⾃动创建⼀个新的`commit`，如果合并时遇到冲突的话，只需要修改后重新`commit`。

- 优点：能记录真实的`commit`情况，包括每个分⽀的详情
- 缺点：由于每次`merge`会⾃动产⽣⼀个`commit`，因此在使用⼀些可视化的git工具时会看到这些自动产生的`commit`，这些`commit`对于程序员来说没有什么特别的意义，多了反而会影响阅读。

1. `git rebase`会合并之前的`commit`历史。

- 优点：可以得到更简洁的提交历史，去掉了merge 产生的`commit`
- 缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息

场景：

- 当需要保留详细的合并信息，建议使⽤`git merge`, 尤其是要合并到`master`上
- 当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的合并记录信息对自己来说没有必要，那么可尝试使用`git rebase`

# 计算机网络相关

## 网络分层及协议

| 协议                          | OSI 7层参考模型（理论成功，市场失败） | TCP/IP 4层参考模型 | 5层参考模型 |
| ----------------------------- | ------------------------------------- | ------------------ | ----------- |
| HTTP、FTP、SMTP、DNS          | 应用层                                | 应用层             | 应用层      |
|                               | 表示层                                |                    |             |
| SSL/TLS                       | 会话层                                |                    |             |
| TCP/UDP                       | 传输层                                | 传输层             | 传输层      |
| IP/ICMP、RIP、OSPF、BGP、IGMP | 网络层                                | 网际层             | 网络层      |
| PPP、CSMA/CD、arp             | 数据链路层                            | 网络接口层         | 数据链路层  |
| Rj45                          | 物理层                                |                    | 物理层      |

CIDR冗余校验是啥？支持可变长度的子网划分和无分类编址 CIDR。



## RIP、OSPF和BGP的区别？

|          | RIP                                                          | OSPF                                   | BGP                                  |
| -------- | ------------------------------------------------------------ | -------------------------------------- | ------------------------------------ |
| 传输范围 |                                                              | 自制系统内部<br />采用组播形式传递报文 | 外部                                 |
| 路由算法 | 路径-向量                                                    | 费用                                   | 多种策略                             |
| 传输协议 | UDP                                                          | IP                                     | TCP                                  |
| 路径选择 | 跳数最少                                                     | 代价最低                               | 较好，非最佳                         |
| 交换对象 | 和本节点相邻的路由器                                         | 自制系统中所有路由器                   | 和本节点相邻的路由器                 |
| 交换内容 | 路由表                                                       | 链路状态                               | 首次：路由表<br />之后：有变化的部分 |
| 更新时机 | 定时发送                                                     | 只有链路状态变化才发                   |                                      |
| 缺点     | 收敛速度慢、路由环路、好消息传递快，坏消息传递慢<br />跳数最大15 | 路由器频繁交换信息，很难保持一致性     |                                      |

其他问题：

为何RIP的跳数最大是15？

为何好消息传递快？慢消息传递慢？

![image-20230922102619458](https://s1.vika.cn/space/2023/09/22/6e54e74979d24bb89c8618e01d1e77f6)

![image-20230922102526383](https://s1.vika.cn/space/2023/09/22/5302b635217f42d5a78be17fdf48f692)

## TCP可靠交付是如何实现的？

有哪些保证可靠交付的算法？这些算法的应用场景？

可靠交付实现途径

- 检验和？

- 序列号/确认应答

- 超时重传：根据SRTT（平滑往返时间Round Trip Time）

- 最大消息长度：TCP连接建立时，约定MSS？？

- 流量控制控制【又名滑动窗口控制】：发送方和接受方维护一个发送窗口和接受窗口。

- 拥塞控制：慢启动、拥塞避免、快速重传和快速恢复

快重传：要求接收方在收到一个失序的报文段后就立即发出重复确认

快恢复算法：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。**【cwnd = ssthresh = cwnd /2】**

出现拥塞：**ssthresh = cwnd /2 cwnd = 1**

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现**拥塞**（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限**ssthresh设置为出现拥塞时的发送窗口大小的一半**（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。



![image-20230922155019236](https://s1.vika.cn/space/2023/09/22/923a5c61240c4da8839b352449289577)

注意：网络堵塞时ssthresh=cwnp/2

# axios统一封装

## axios如何二次封装

[面试官：Vue项目中有封装过axios吗？怎么封装的？_动感超人，的博客-CSDN博客](https://blog.csdn.net/weixin_44475093/article/details/111878425)

### 为何封装

如果每发起一次`HTTP`请求，就要把这些比如**设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理**等等操作，都需要写一遍

这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 `axios` 再使用

### 如何封装

封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间.......

- 设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分

- 请求头 :  来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)

- 状态码:   根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好

- 请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便

- 请求拦截器:  根据请求的请求头设定，来决定哪些请求可以访问

- 响应拦截器：这块就是根据 后端`返回来的状态码判定执行不同业务

## CSRF怎么防御

[CSRF 原理、攻击、防御及其他 - 掘金 (juejin.cn)](https://juejin.cn/post/7076795827645055013)



- CSRF token【最根本的方法】，Samesite Cookie属性可以禁止第三方站点读取cookie

- 验证码：方法：这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以解决CSRF。【最常用且可靠】

- 在表单中，生成一个隐藏域，它的值就是COOKIE中随机TOKEN。
- 检查HTTP请求头Referer Origin字段【不可靠】
- 

## token清除的时机？

用户浏览器关闭、或用户再次登录、或退出时，清除token

## token存放位置

看需求：如果需要关闭浏览器之后下次用户需要登录才能正常使用功能sessionStorage

如果需要关闭浏览器之后一段时间内可以正常使用功能localStorage

1. **如果需要窗口关闭之后一段时间内还可以直接进入系统，就使用localStorage存储token。**
2. **如果需要窗口关闭之后不能直接进入系统，而需要输入密码，则使用sessionStorage。**

- 将**localStorage替换成sessionStorage来存储token**，可以完美实现关闭浏览器后清除token的效果。



## 页面刷新vuex中数据丢失问题

[两种方式解决页面刷新vuex中数据丢失问题（详细讲解） - 掘金 (juejin.cn)](https://juejin.cn/post/7020615600359604260)



## cookie和session的区别

cookie详解：[cookie一般存储什么？怎么设置cookie?_在前端页面中,一般使用cookie来存储用户的以下哪类信息比较合适?_七彩冰淇淋与藕汤的博客-CSDN博客](https://blog.csdn.net/qq_36582776/article/details/123677939)

1. 有两种存储类型的Cookie：会话性与持久性。

- Expires属性缺省时，为会话性Cookie，仅保存在[客户端](https://baike.baidu.com/item/客户端/101081)内存中，并在用户关闭浏览器时失效；
- 持久性Cookie会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效 。



## JSON.stringify深拷贝的问题

MDN：[JSON.stringify() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)

- undefined丢失
- Symbol丢失
- BigInt报错
- 不可枚举的属性默认会被忽略
- undefined/会变空 JSON.stringify([undefined, Object, Symbol("")]);
  // '[null,null,null]'

|              | 对象 | 数组 |
| ------------ | ---- | ---- |
| undefined    | 丢失 | null |
| Symbol       | 丢失 | null |
| {}           | 丢失 | null |
| 不可迭代属性 | 丢失 |      |



```js
JSON.stringify({}); // '{}'
JSON.stringify(true); // 'true'
JSON.stringify("foo"); // '"foo"'
JSON.stringify([1, "false", false]); // '[1,"false",false]'
JSON.stringify({ x: 5 }); // '{"x":5}'

JSON.stringify({ x: 5, y: 6 });
// "{"x":5,"y":6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]'

JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {
  if (typeof k === "symbol") {
    return "a symbol";
  }
});

// undefined

// 不可枚举的属性默认会被忽略：
JSON.stringify(
  Object.create(null, {
    x: { value: "x", enumerable: false },
    y: { value: "y", enumerable: true },
  }),
);

// "{"y":"y"}"

```



## localStorage、sessionStorage的区别





## 前端怎么处理跨域问题

开发环境

配置devServer

生产环境

- CORS
- jsonp

```js
function test() {
    // 外部域名，参数是和后端接口约定的callback指定接口返回后的回调函数
    url = "http://localhost:8882/test?callback=_ajax_callback";
    // 创建一个script元素
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    document.head.appendChild(script);
}

// 接口回调
function _ajax_callback(res) {
    console.log("被回调了");
    console.log(res);
}

```

## script的type有哪些属性

```js
<script type="text/javascript"></script>【默认】

<script id="json-script" type="application/json">
```



## Access-Control-Allow-Origin怎么配置

开发环境

## HTML的meta部分有哪些属性？是用来干什么的？

```html
<meta charset="UTF-8"> 字符集
<meta content="origin" name="referrer">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>视窗设置
```

## 路由导航守卫有哪些

按照顺序

![image-20230814085036553](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230814085036553.png)

![image-20230814085121242](C:\Users\hang\AppData\Roaming\Typora\typora-user-images\image-20230814085121242.png)

## 浏览器性能优化评价指标

web应用的常见性能指标：页面加载时间、全部页面加载时间、首字节时间、DNS时间、TCP时间、页面渲染、下载速度、页面流畅度、网络丢包率、网络时延、请求响应时间、事务响应时间、并发用户数等。

## XMLHttprequest2 相比 XMLHttpRequest1的变化

[XMLHttpRequest Level 2 使用指南 - 阮一峰的网络日志 (ruanyifeng.com)](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)

![image-20230904101929917](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230904101929917.png)

## Access-Control-Allow-Origin与Access-Control-Allow-Credentials

## JS如何判断数据类型呢

- **布尔值（Boolean）**，有 2 个值分别是：true 和 false.
- **null**，一个表明 null 值的特殊关键字。JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。
- **undefined**，和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。
- **数字（Number）**，整数或浮点数，例如： 42 或者 3.14159。
- **字符串（String）**，字符串是一串表示文本值的字符序列，例如："Howdy" 。
- **代表（Symbol）**( 在 ECMAScript 6 中新添加的类型).。一种实例是唯一且不可改变的数据类型。
- **任意精度的整数 (BigInt)** ，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。

2.以及**对象（Object）**，即引用类型。包括 Object Array、Function 等。

## **堆和栈的区别？**

[腾讯面试必问题：堆与栈的区别 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/387842617)包括常见实现和常见方法

> 内存管理方面

|              | 栈                                                           | 堆                                                           |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 管理方式     | 操作系统自动分配释放，无需我们手动控制                       | 操作系统自动分配释放，无需我们手动控制                       |
| 空间大小     | 进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB | 程序员可申请的堆大小为虚拟内存的大小                         |
| 生长方向     | 堆的生长方向向上，内存地址由低到高                           | 栈的生长方向向下，内存地址由高到低                           |
| 分配方式     | 堆都是动态分配的，没有静态分配的堆                           | 栈有2种分配方式：静态分配和动态分配。<br />静态分配是由操作系统完成的，比如局部变量的分配。<br />动态分配由alloca函数进行分配，<br />但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现 |
| 分配效率     |                                                              |                                                              |
| 存放内容不同 |                                                              |                                                              |

> 数据结构方面

> 栈：栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作
>
> 堆：是一种特殊的完全二叉树

补充：二叉树的存储方式？[二叉树的存储方式【顺序储存（数组）、链式存储、邻接表存储等】_马小超i的博客-CSDN博客](https://blog.csdn.net/qq_21989927/article/details/108666433#:~:text=二叉树的存储方式【顺序储存（数组）、链式存储、邻接表存储等】 1 1.顺序存储结构 二叉树的顺序存储，就是用一组连续的存储单元存放二叉树中的结点。 因此，必须把二叉树的所有结点安排成为一个恰当的序列，结点在这个序列中的相互位置能反映出结点之间的逻辑关系，用编号的方法从树根起，自上层至下层，每层自左至右地给所有结点编号%2C缺点是有可能对存储空间造成极大的浪费，在最坏的情况下，一个深度为k且只有k个结点的右单支树需要2k-1个结点存储空间。 ... 2 2.,%2C y 之间有一条边，但是并不知道 x %2C y 的父子关系的时候，可以使用邻接表的方法存储树。 )

顺序储存（数组）、链式存储、二维数组直接存储、邻接表存储等

**为什么基本数据类型要放在栈中，而引用数据类型放在堆中？**

> 基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。 
>
> 引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小

[为什么JS基础数据类型要放栈内存？ - 掘金 (juejin.cn)](https://juejin.cn/post/7087961163153014820)

[「前端进阶」JS中的栈内存堆内存 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79840222#:~:text=引用数据类型存储,大、大小不固定。)



## 讲下进程和线程的区别【美团二面，腾讯一面】

[进程和线程的区别(超详细)-CSDN博客](https://blog.csdn.net/ThinkWon/article/details/102021274)

> 进程通常包含了程序代码、数据、文件描述符等资源，并且有自己的地址空间、堆栈和寄存器等上下文信息
>
> 线程则是进程中的一条执行路径，它与同一进程内的其他线程共享该进程的资源，包括内存、文件句柄等。每个线程都有自己的堆栈和寄存器，但它们之间可以共享同一进程的代码段、数据段和全局变量等

|              | 进程                                                         | 线程                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **根本区别** | 操作系统资源分配的基本单位                                   | 处理器任务调度和执行的基本单位                               |
| **资源开销** | 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销 | 线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小 |
| **包含关系** | 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的 | 线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程   |
| **内存分配** | 进程之间的地址空间和资源是相互独立的                         | 线程共享本进程的地址空间和资源                               |
| **影响关系** | 一个进程崩溃后，在保护模式下不会对其他进程产生影响           | 一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮         |
| **执行过程** | 每个独立的进程有程序运行的入口、顺序执行序列和程序出口       | 线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 |
|              |                                                              | 充分利用多核CPU的优点                                        |

### 既然有了进程为什么还要设计线程？

进程缺点：

- 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。
- 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。
- 无法充分利用多核CPU的优点【猜的】

### 为什么js要设计成单线程的？单线程的好处

这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变

js单线程与时间循环联系起来！讲的比较好

[为什么javascript是单线程？_js没多线程_RuGuo_09的博客-CSDN博客](https://blog.csdn.net/baidu_24024601/article/details/51861792)

### 同步ajax和异步ajax？



### 进程和程序的区别？

进程包含程序的代码、数据和执行环境

### 多进程和多线程的区别

多进程：操作系统中同时运行的多个程序

多线程：在同一个进程中同时运行的多个任务

举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：随机性。造成的原因：CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。

多线程提高CPU使用率



## 说下驱动程序的作用【美团二面】感觉一个开放题

- 设备初始化：驱动程序负责初始化硬件设备，包括设备的寄存器、端口、中断等设置。这样操作系统才能正确地与设备进行通信。

- 设备管理：驱动程序提供了对设备的管理和控制功能，如打开和关闭设备、配置设备参数以及维护设备状态等。

- 数据传输：驱动程序负责数据在设备和操作系统之间的传输，包括读取设备数据到内存和从内存向设备写入数据。

- 中断处理：当硬件设备发生中断时，驱动程序会处理中断请求，响应设备的中断信号，并将相应的数据交给操作系统处理。

- 错误处理：驱动程序负责监测设备错误，并采取相应的措施。它可以识别硬件故障、错误状态和异常情况，并向操作系统报告或采取纠正措施。

驱动程序是一种特殊的软件，它与特定的硬件设备交互，提供对硬件设备的访问和控制接口。驱动程序通常由硬件设备的制造商提供，用于与操作系统进行交互，使得操作系统可以正确地识别、配置和控制硬件设备。驱动程序负责将操作系统发出的命令和请求转化为硬件设备可以理解和执行的操作。驱动程序可以控制各种硬件设备，包括处理器、内存、硬盘、网络接口、打印机等。

计算机组成原理：硬件 驱动程序 操作系统 软件

> 玩过单片机的都知道点亮LED吧，多容易啊，往某个寄存器写0或者1就行了，几行C代码就搞定了，是不?
>
> 驱动程序，就是衔接操作系统与外部的硬件的C代码。
>
> 当你要透过操作系统去访问硬件的时候，就需要驱动程序了，你需要先写一个app，然后从app通过设备节点，透过操作系统去往寄存器写0或者1，然后点亮LED。

> 总结一句话，驱动就是把硬件抽象化成软件。
>
> 首先，假如是无操作系统的情况下，那么驱动程序其实就是操作硬件寄存器的裸机程序，你通过了解这个硬件的工作原理、通讯方式，需要从硬件的寄存器读写，你把这一套流程做好了，做成一个接口，放在接口库，那么那些做单片机的就可以直接调用你的接口去做开发。
>
> 然后，假如是有操作系统的情况下，操作硬件的权限是只有内核才有的，这是为了安全，应用程序没有这个权限，那么假如你的桌面应用程序实现的一些功能需要操作硬件，那么就需要安装驱动程序，驱动程序知道如何去跟内核要某个层要东西，要的就是这个桌面应用软件从硬件需要的东西。假如是嵌入式的应用程序，一般驱动程序都是已经写好捆绑在内核上、或者动态加载，而应用程序只需调用内核提供的接口即可间接调用驱动程序，从而件间间接操作硬件，甚至有几个层的话那么就是间间间接操作硬件。
>
> 最后，说白了就是，为了安全，应用程序不直接操作硬件，这里面涉及到中断、抢占等等问题，所以需要做个抽象化。
>
> ——————————————
>
> 更新一下，在这个面向对象的世界，你可以把驱动理解为模块（.ko/.o）和固件（.bin/.img）。
>
> 功能就是实现软件对硬件的操作以及如何操作。
>
> 这样说就很简单了。

### 注意区分操作系统和驱动程序

[什么是操作系统？操作系统的作用都有哪些？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/392002967)

## 32位操作系统和64位操作系统有哪些区别？

这个问题前面试官会问对c语言的了解程度，嗯，一言难尽

- 首要的区别是32位和64位CPU的指令集合、操作数位数、寄存器名称和个数都不相同

# 补充部分

## el-tree的实现

[vue组件的递归自调用~代码思路分析 - 掘金 (juejin.cn)](https://juejin.cn/post/7014130015902105636)

```vue
<ul>  
	<li v-for="(item, index) in data" :key="index">
      {{ item.name }}
      <!-- 在遍历时递归调用组件自身，当然，要有children，有数据的时候才去递归调用自身(递归需要有一个结束条件) -->
      <template v-if="item.children">
        <tree :data="item.children"></tree>
        <!-- 因为组件调用渲染，需要有数据，而这个tree.vue组件是的数据是通过props接收的，
        所以需要把子内容数据再传递给子组件，子组件用props接收，就能够一层一层的渲染了 -->
      </template>
    </li>
  </ul>
```

之后看：[el-tree懒加载中使用递归更改树节点状态值 - 掘金 (juejin.cn)](https://juejin.cn/post/7016658420656766989)

## axios配置api二次封装

**为什么要进行二次封装（用途）：**可以在真实项目开发中让问题发现提前

**原理：**axios原理：借助XMLHttprequest2实现





## 统一跨域处理

### **怎么处理跨域问题？**

开发环境：proxy代理，nginx反向代理

生产环境：jsonp实现？如何实现？

### CORS场景

![image-20230904152244790](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230904152244790.png)

跨域资源共享CORS？如何实现

服务端配置借助请求头**Access-Controll-Allow-Origin**，配置为：*。响应头中的Access-Control-Allow-Origin一定不能为*\*，必须是指定的域名

**原理：**对于简单请求，如请求方法是get/post/head，会在请求头会添加Origin字段指出当前请求的域。

```
跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。MDN
```

假如不想配置允许所有用户访问，该如何配置？

### CSRF中可能出现的CSRF攻击如何防范？

先看第一种思路的攻击场景：

1,复杂csrf。传统的csrf都是利用html标签和表单来发送请求。没有办法实现一些复杂步骤的csrf，比如模拟购物，先加购物车，结算，填写信息，等等。比如上传文件。具体可以参考利用csrf上传文件

2,访问内网敏感资源。这个在一定的条件下是可以实现的。比如内网的服务器配置了

Access-Control-Allow-Origin: * 允许任何来自任意域的跨域请求

用户访问恶意网页的时候，执行了到内网服务器192.168.1.123/password.txt的请求，脚本在接收到服务器返回之后，将内容发送到攻击者的服务器上。

第二种思路的场景:

1,交互式xss。参考揭密HTML5带来的攻击手法中讲到的shell of the future工具。通过cors，绕过一些反会话劫持的方法，如HTTP-Only限制的cookie，绑定IP地址的会话ID等，劫持用户会话。

2,程序猿在写ajax请求的时候，对目标域限制不严。有点类似于url跳转。facebook出现过这样一个案例。javascript通过url里的参数进行ajax请求。通过控制这个参数实现注入攻击。

```
4    CSRF漏洞防御
CSRF漏洞防御主要可以从三个层面进行，即服务端的防御、用户端的防御和安全设备的防御。

4.1      服务端的防御
目前业界服务器端防御CSRF攻击主要有三种策略：验证HTTP Referer字段，在请求地址中添加token并验证，在HTTP头中自定义属性并验证。下面分别对这三种策略进行简要介绍。

4.1.1        验证HTTP Referer字段
根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问http://bank.test/test?page=10&userID=101&money=10000页面完成，用户必须先登录bank. test，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL（本例中，通常是以bank. test域名开头的地址）。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank. test开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。

4.1.2        在请求地址中添加token并验证
CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。

4.1.3        在HTTP头中自定义属性并验证
自定义属性的方法也是使用token并进行验证，和前一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了前一种方法在请求中加入token的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心token会通过Referer泄露到其他网站。

4.2      用户端的防御
    对于普通用户来说，都学习并具备网络安全知识以防御网络攻击是不现实的。但若用户养成良好的上网习惯，则能够很大程度上减少CSRF攻击的危害。例如，用户上网时，不要轻易点击网络论坛、聊天室、即时通讯工具或电子邮件中出现的链接或者图片；及时退出长时间不使用的已登录账户，尤其是系统管理员，应尽量在登出系统的情况下点击未知链接和图片。除此之外，用户还需要在连接互联网的计算机上安装合适的安全防护软件，并及时更新软件厂商发布的特征库，以保持安全软件对最新攻击的实时跟踪。
```





### 附加

[跨域问题（CORS）的解决 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/121042077#:~:text=Access-Control-Allow-Origin：允许哪个域名进行跨域，是一个具体域名或者*（代表任意域名） Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true,要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。)

- 简单请求

<img src="https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230904112102506.png" alt="image-20230904112102506" style="zoom:67%;" />

> 简单请求（需要同时满足以下两大条件）
>
> 1. 请求方法是以下三种方法之一
>    - HEAD
>    - GET
>    - POST
> 2. HTTP的头信息不超出以下几种字段：
>    - Accept
>    - Accept-Language
>    - Content-Language
>    - Last-Event-ID
>    - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

## HTTPS的加密过程

SSL连接过程[HTTPS详解二：SSL / TLS 工作原理和详细握手过程 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000021559557)

入门了解：[HTTPS及加密算法总结_https加密算法_xyzhang2018的博客-CSDN博客](https://blog.csdn.net/qq_41701363/article/details/115876339)

深入讲透彻：[彻底搞懂HTTPS的加密原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/43789231)

![image-20230908090809869](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230908090809869.png)

加密算法整体可以分为：可逆加密、不可逆加密

可逆加密又可以分为对称加密和非对称加密

一、可逆加密
1. 对称加密算法
对称加密算法，又称为共享密钥加密算法。在数据加密和解密时使用的是同一个密钥，这就导致密钥管理困难的问题。常见的对称加密算法有DES, 3DES, AES128, AES192, AES256。其中AES后面的数字代表的是密钥长度。对称加密算法的安全性相对较低，比较适合内网环境中加解密。

1.1 DES
DES加密算法是一种分组密码，以64位为分组对数据加密，它的密钥长度是56位，加解密用同一算法。

1.2 3DES
基于DES的加密算法，3DES（即Triple DES）是DES向AES过渡的加密算法，它使用3个不同的56位的密钥对一块数据进行三次加密，强度更高。

1.3 AES算法
AES 高级数据加密标准，能够有效抵御已知的针对DES算法的所有攻击，默认密钥长度为128位，还可以供选择192位，256位。这里顺便提一句这个位指的是bit。

2. 非对称加密算法
非对称加密算法，又称为公开密钥加密算法。这两个密钥完全不同但又完全匹配，只有使用匹配的一堆公钥和私钥，才能完成对明文的加密和解密过程。常见的非对称加密有RSA, SM2 等

非对称加密的特点是1 v n，服务器只需要一个私钥就能和多个客户端进行加密通信。而对称加密则需要针对每个客户端保存一个密钥。
2.1 RSA
RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。

2.2 ECC算法
ECC 也是一种 非对称加密算法，主要优势是在某些情况下，它比其他的方法使用 更小的密钥，比如 RSA 加密算法，提供 相当的或更高等级 的安全级别。不过一个缺点是 加密和解密操作 的实现比其他机制 时间长 (相比 RSA 算法，该算法对 CPU 消耗严重)。

## MD5加密优点

MD5信息摘要算法（Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。本质上，其就是一种哈希函数，用于对一段信息产生摘要，以防止被篡改。

MD5 算法有以下特点：

压缩性：无论数据长度是多少，计算出的MD5值长度相同，均为128位
容易计算性：由原数据可以很快计算出MD5值
抗修改性：即使修改一个字节，计算出的MD5值也会产生巨大差异
抗碰撞性：知道数据和MD5值很难找到相同MD5的原数据



httprequest2

## 阻止事件冒泡和事件捕获

> 阻止事件冒泡：`event.stopPropagation()` 只会阻止事件在 DOM 树中的冒泡传播，而不会影响事件在当前元素内部的传播
>
> 事件捕获：`event.stopImmediatePropagation()` 不仅会阻止事件的捕获传播，还会阻止同一元素上后续绑定的其他事件处理程序的执行。也就是说，如果在同一个元素上有多个事件处理程序，并且其中一个调用了 `event.stopImmediatePropagation()`，其他事件处理程序将不会被触发。
>
> event.stopImmediatePropagation() = event.stopPropagation() + event.preventDefault()

## HTTP版本发展历史

[「2021」高频前端面试题汇总之计算机网络篇 - 掘金 (juejin.cn)](https://juejin.cn/post/6908327746473033741#heading-9)

| 协议版本    | 支持的请求方式  | 连接持久性                                                   | 缓存相关                                                     | 相比上个版本新增                                             |
| ----------- | --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **HTTP0.9** | get             |                                                              |                                                              |                                                              |
| **HTTP1.0** | GET、HEAD、POST | 默认非持久连接，不支持断点续传、<br />长连接： Connection: Keep-Alive | 主要使用 header 里的 If-Modified-Since、Expires 【1.0】来做为缓存判断的标准<br />默认：默认情况下，浏览器会假定每个响应都可以缓存，并且在后续请求相同资源时会使用缓存的副本。 | 支持响应头，请求头<br />新增协议版本<br />支持传输纯文本以外的内容 |
| **HTTP1.1** | PUT、OPYIONS    | 默认持久连接<br />增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟，解决队头堵塞现象 | http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match，cache-control【1.1新增】 等更多可供选择的缓存头来控制缓存策略<br />浏览器会将"Cache-Control"设置为"private"，表示资源只能被单个用户缓存，不能在用户之间共享。这是为了保护用户的隐私。 | **新增了 host 字段**，用来指定服务器的域名<br />还新增了很多**请求方法**，如 PUT、HEAD、OPTIONS 等<br />支持**断点续传**（响应分块），TCP复用、引入内容协商机制 |
| **HTTP2.0** |                 | 这是一个多路复用协议，解决队头堵塞问题                       |                                                              | HTTP/2 是一个二进制协议，不再是文本协议<br />数据流、头信息压缩、服务器推送 |
| **HTTP3.0** |                 | 但在传输层部分使用 [QUIC (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/QUIC) 而不是 [TCP](https://developer.mozilla.org/zh-CN/docs/Glossary/TCP) | HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。 |                                                              |

**管线化技术：**每个指令被分解为多个阶段，如取指、解码、执行、访存和写回等。这些阶段形成了一个流水线，允许多个指令在不同阶段同时执行，从而实现指令级并行性

**多路复用**：【时分复用（TDM）、频分复用（FDM）和分组多路复用（PDM）】。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。

**区别：**

- 多路复用是一种通过共享通信信道实现多个数据流的传输技术，用于提高通信资源的**利用率和传输效率。**
- 管线化是一种通过将指令执行过程划分为多个阶段并同时执行多个指令的技术，用于提高计算机处理器的**吞吐量和性能。**

**1.0版本的Connection的好处和坏处**

开启Keep-Alive的**优点：**

- 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
- 允许请求和应答的HTTP管线化；
- 降低拥塞控制 （TCP连接减少了）；
- 减少了后续请求的延迟（⽆需再进⾏握⼿）；
- 报告错误⽆需关闭TCP连；

开启Keep-Alive的**缺点**：

- 长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。

### 页面有多张图片，HTTP是怎样的加载表现？

- 在`HTTP 1`下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用**多域名部署**解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
- 在`HTTP 2`下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。

### HTTP协议的优点和缺点

HTTP协议具有以下**优点**：

- **支持客户端/服务器模式**
- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
- **无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
- **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
- **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

HTTP协议具有以下**缺点**：

- **无状态：** HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
- **明文传输：** 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
- **不安全**

（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；

### http和https区别

HTTP协议采用**明文传输**信息，存在**信息窃听**、**信息篡改**和**信息劫持**的风险，而协议TLS/SSL具有**身份验证**、**信息加密**和**完整性校验**的功能，可以避免此类问题发生。

### 既然HTTPS优点那么多，为何现在还主流使用http1.1呢？

https缺点：

- HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；
- HTTPS协议握手阶段比较费时，增加页面的加载时间；
- SSL证书是收费的，功能越强大的证书费用越高；
- HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；
- SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。

**为什么http3已经出来了，却还是沿用http1.1呢？**

- **兼容性：**HTTP/1.1是互联网上广泛采用的协议之一，几乎所有的现代浏览器和服务器都支持HTTP/1.1。由于存在大量使用HTTP/1.1的网站和系统，迁移到新的协议需要时间和资源，因此HTTP/1.1仍然被广泛使用以确保向后兼容性。
- **部署成本：**部署新的协议需要更新服务器和客户端的软件、配置和基础设施。采用新的协议需要进行验证、测试和适应性调整，这涉及到一定的成本和风险。因此，许多网站和系统可能选择继续使用HTTP/1.1，而不是立即转移到HTTP/2或HTTP/3。
- **兼容性和支持：**HTTP/2和HTTP/3的支持需要浏览器、服务器和网络设备等各个环节的配合。尽管现代浏览器和服务器已经开始广泛支持HTTP/2和HTTP/3，但仍然存在一些旧版浏览器、代理服务器和网络设备不完全支持这些新协议的情况。这可能导致在某些环境中无法充分利用HTTP/2和HTTP/3的优势。
- **逐步过渡**：由于HTTP/1.1的广泛应用和网络生态的复杂性，迁移到新的协议需要时间和协调。为了实现更平滑的过渡，采用渐进式的策略是更合理的选择。因此，HTTP/1.1仍然被广泛使用，而HTTP/2和HTTP/3的部署和采用会逐步进行，并需要时间来实现全面的接受和支持。

### 请求方法及应用场景

序号	方法	描述
1	GET	请求指定的页面信息，并返回实体主体。
2	HEAD	类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
3	POST	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
4	PUT	从客户端向服务器传送的数据取代指定的文档的内容。
5	DELETE	请求服务器删除指定的页面。
6	CONNECT	HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
7	OPTIONS	允许客户端查看服务器的性能。
8	TRACE	回显服务器收到的请求，主要用于测试或诊断。
9	PATCH	是对 PUT 方法的补充，用来对已知资源进行局部更新 。

### 请求状态码

**（1）2XX 成功**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- 206 Partial Content，进行范围请求

**（2）3XX 重定向**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

**（3）4XX 客户端错误**

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

**（4）5XX 服务器错误**

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### TCP和UDP的区别【美团二面，4399一面】

|              | UDP                                        | TCP                                                  |
| ------------ | ------------------------------------------ | ---------------------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                                             |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                                     |
| 传输方式     | 面向报文                                   | 面向字节流                                           |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节                           |
| 适用场景     | 适用于实时应用，例如视频会议、直播         | 适用于要求可靠传输的应用，例如文件传输               |

**TCP和UDP的使用场景**

- **TCP应用场景：** 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
- **UDP应用场景：** 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

**UDP不可靠原因：**

- 不保证消息交付：不确认，不重传，无超时
- 不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞
- 不跟踪连接状态：不必建立连接或重启状态机
- 不进行拥塞控制：不内置客户端或网络反馈机制

现在咱们视频使用的是那个？UDP

### js如何操作UDP有了解吗？【美团二面】

先问的现在咱们开会用的TCP还是UDP

理论上讲自然UDP比较适合，然而现实却是使用TCP。

TCP占绝对份额，rtmp或者hls都是基于TCP

> 感觉面试官想问的是HTTP3.0是的QUIC协议是如何利用UDP实现TCP的可靠传输的？

### TCP的拥塞控制机制是什么？

ssthresh：慢开始门限值

cwnd ：拥塞窗口

RTT：往返时间

RTO:报文超时时间



腾讯面试题
TCP的拥塞控制机制是什么？请简单说说。
答：我们知道TCP通过一个定时器（timer）采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况。
首先需要了解一个概念，为了在发送端调节所要发送的数据量，定义了一个“拥塞窗口”（Congestion Window），在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。
拥塞控制主要是四个算法：
1.慢启动：意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。
连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。
每当收到一个ACK，cwnd++; 呈线性上升
每当过了一个RTT，cwnd = cwnd*2; 呈指数让升
阈值ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”
2.拥塞避免：当拥塞窗口 cwnd 达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。
每当收到一个ACK，cwnd = cwnd + 1/cwnd
每当过了一个RTT，cwnd = cwnd + 1
拥塞发生：当发生丢包进行数据包重传时，表示**网络已经拥塞**。分两种情况进行处理：
等到RTO超时，重传数据包
sshthresh = cwnd /2
cwnd 重置为 1
3.进入慢启动过程
在收到3个duplicate ACK时就开启重传，而不用等到RTO超时
sshthresh = cwnd = cwnd /2
进入快速恢复算法——Fast Recovery
4.快速恢复：至少收到了3个Duplicated Acks，说明**网络也不那么糟糕，可以快速恢复**。
cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）
重传Duplicated ACKs指定的数据包
如果再收到 duplicated Acks，那么cwnd = cwnd +1
如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。

原文：[TCP拥塞控制机制（附面试题）_sHuXnHs的博客-CSDN博客](https://blog.csdn.net/shuxnhs/article/details/80644531)

[TCP流量控制、拥塞控制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37379780)【比较通透】

[计算机网络必考之·TCP的拥塞控制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/438366056)【快开始彻底理解】

### HTTPS的优点

尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：

　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 　　

（5）百度也在今年发布了《百度对HTTPS站点的扶持态度》，并提供了多种通用的https改造解决方案。（详见：https://ziyuan.baidu.com/college/articleinfo?id=1814）

### HTTPS的缺点

虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：

　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

　  （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个[域名](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.feimao666.com%2Fbangzhu%2F2016%2F1227%2F34.html)，IPv4资源不可能支撑这个消耗。

　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

### HTTP和HTTPS的区别

HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

# 缓存机制

[HTTP缓存的三种方式详解 - 掘金 (juejin.cn)](https://juejin.cn/post/7063861101041025031)

强缓存：优先级Pragma（兼容1.0） > Cache-Control （1.1）> Expires（1.0）【过期时间】

> Cache-Control：HTTP1.1属性，优先级更高，以下为常用属性
>
> - no-store： 禁用缓存
> - no-cache：不使用强缓存，每次需向服务器验证缓存是否失效
> - private/public：private指的单个用户，public可以被任何中间人、CDN等缓存
> - max-age=：max-age是距离请求发起的时间的秒数
> - must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证

协商缓存：优先级ETag>Last Motify 

<img src="https://s1.vika.cn/space/2023/09/25/94b6d17dd1ed4478890f56426f3e741c" alt="image-20230925142715969" style="zoom:50%;" />

### Cache-Control常见的属性有哪些？

- no-store： 禁用缓存
- no-cache：不使用强缓存，每次需向服务器验证缓存是否失效
- private/public：private指的单个用户（仅客户端可以缓存，代理服务器不可缓存），public可以被任何中间人、CDN等缓存
- max-age=：max-age是距离请求发起的时间的秒数
- must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证

### **为什么要使用HTTP缓存 ？**

根据上面的学习可发现使用缓存的好处主要有以下几点：

- 1. 减少了冗余的数据传输，节省了网费。
  2. 缓解了服务器的压力， 大大提高了网站的性能
- 3. 加快了客户端加载网页的速度

###  **如何使用HTTP缓存 ？**

一般需要缓存的资源有html页面和其他静态资源：

**1、html页面缓存的设置主要是在<head>标签中嵌入<meta>标签，这种方式只对页面有效，对页面上的资源无效**

1.1、html页面禁用缓存的设置如下：

<meta http-equiv="pragma" content="no-cache">

// 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求

<meta http-equiv="cache-control" content="no-cache">

// 其他主流浏览器识别的标签

<meta http-equiv="expires" content="0"> 

// 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段



1.2、html设置缓存如下：

<meta http-equiv="Cache-Control" content="max-age=7200" />

// 其他主流浏览器识别的标签

<meta http-equiv="Expires" content="Mon, 20  Aug 2018 23:00:00 GMT" />

// 仅有IE浏览器才识别的标签



2、静态资源的缓存一般是在web服务器上配置的，常用的web服务器有：nginx、apache。具体的配置这里不做详细介绍，大家自行查阅。



**3、不想使用缓存的几种方式：**

3.1、Ctrl + F5强制刷新，都会直接向服务器提取数据。

3.2、按F5刷新或浏览器的刷新按钮，默认加上Cache-Control：max-age=0，即会走协商缓存。

3.2、在IE浏览器下不想使用缓存的做法：打开IE，点击工具栏上的工具->Internet选项->常规->浏览历史记录 设置. 选择“从不”，然后保存。最后点击“删除”把Internet临时文件都删掉 （IE缓存的文件就是Internet临时文件）。

3.3、还有就是上面1、2中禁用缓存的做法

3.4、对于其他浏览器也都有清除缓存的办法

 **HTTP缓存的几个注意点**

1、强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器端有数据变化，也不会从服务器端获取了，这样就无法获取到修改后的数据。决解的办法有：在修改后的资源加上随机数,确保不会从缓存中取。

例如：

http://www.kimshare.club/kim/common.css?v=22324432

http://www.kimshare.club/kim/common.2312331.css

2、尽量减少304的请求，因为我们知道，协商缓存每次都会与后台服务器进行交互，所以性能上不是很好。从性能上来看尽量多使用强缓存。

3、在Firefox浏览器下，使用Cache-Control: no-cache 是不生效的，其识别的是no-store。这样能达到其他浏览器使用Cache-Control: no-cache的效果。所以为了兼容Firefox浏览器，经常会写成Cache-Control: no-cache，no-store。

4、与缓存相关的几个header属性有：Vary、Date/Age。

**Vary：**

vary本身是“变化”的意思，而在http报文中更趋于是“vary from”（与。。。不同）的含义，它表示服务端会以什么基准字段来区分、筛选缓存版本。

在服务端有着这么一个地址，如果是IE用户则返回针对IE开发的内容，否则返回另一个主流浏览器版本的内容。

格式：Vary: User-Agent

知会代理服务器需要以 User-Agent 这个请求首部字段来区别缓存版本，防止传递给客户端的缓存不正确。

**Date/Age：**

响应报文中的 Date 和 Age 字段：区分其收到的资源是否命中了代理服务器的缓存。

Date 理所当然是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。

Age 也是响应报文中的首部字段，它表示该文件在代理服务器中存在的时间（秒），如文件被修改或替换，Age会重新由0开始累计。





用户操作的影响：![image-20230911085805122](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230911085805122.png)

**项目实现**设置不缓存

```html
<meta http-equiv="pragma" content="no-cache"> 
<meta http-equiv="Cache-Control" content="no-cache, must-revalidate"> 
<meta http-equiv="expires" content="Wed, 26 Feb 1997 00:00:00 GMT">
```

服务端响应添加`Cache-Control:no-cache,must-revalidate`指令；

修改请求头`If-modified-since:0`或`If-none-match`；

请求url后增加时间戳；

服务端设置Cache-Control:private指令，防止代理服务器缓存资源

- 先判断资源是否命中强缓存，命中则直接从disk里拿到资源；【cache-controll/Pragma/Expirs（已废弃）】
- 如果没有命中强缓存，判断是否命中协商缓存，命中则走协商缓存；【Last-Modified/ETag】
- 如果命中了协商缓存，会发起请求，服务端根据Request Header里的If-None-Match（对应Etag）和If-Modified-Since（对应Last-Modified）判断资源是否过期，没过期则返回304状态码，浏览器依旧用disk里的资源。如果资源过期，则服务端会返回新的资源；
- 如果也没有命中协商缓存，则这个请求不走缓存策略，发起真实的请求，从服务端拿资源；

### **cache-control在请求头和响应头的区别**

| Cache-Control【post无效】    | 请求头【客户端只能控制走不走强缓存】                         | 响应头 |
| ---------------------------- | ------------------------------------------------------------ | ------ |
| no-cache【~~不走协商缓存~~】 | 一般会附带Pragma: no-cache，是为了兼容http1.0                |        |
| no-store                     | 无效                                                         |        |
| max-age=0                    | 这个请求按照协商缓存的规则走                                 |        |
|                              | cache-control为：'no-store' / 'no-cache【不使用强缓存，使用协商缓存】' /'max-age=0'才会生效（也就是客户端不想走强缓存的时候生效） |        |

[HTTP请求头和响应头中cache-control的区别 - 简书 (jianshu.com)](https://www.jianshu.com/p/f7ccad796058)

### no-cache 和 no-store 的区别

- no-store

**永远都不要在客户端存储资源**，永远都去原始服务器去获取资源。

- no-cache

可以在客户端存储资源，**每次都必须去服务端做新鲜度校验**，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存。



## 路由相关

### history与hash模式部署时的区别

**hash 与 history 区别对比：**

| hash                                                         | history                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 有 # 号                                                      | 没有 # 号                                                    |
| 能够兼容到IE8                                                | 只能兼容到IE10                                               |
| 实际的url之前使用哈希字符，这部分url不会发送到服务器，不需要在服务器层面上进行任何处理 | 每访问一个页面都需要服务器进行路由匹配生成 html 文件再发送响应给浏览器，消耗服务器大量资源 |
| 刷新不会存在 404 问题                                        | 浏览器直接访问嵌套路由时，会报 404 问题。<br />原因：www.xxx.com/login 页执行刷新操作，nginx location 是没有相关/login配置的，所以就会出现 404 的情况<br />解决方案：重定向到index.html |
| 不需要服务器任何配置                                         | 需要在服务器配置一个回调路由                                 |

**hash模式**

使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：

- hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如[http://localhost/index.html#abc](https://link.juejin.cn?target=http%3A%2F%2Flocalhost%2Findex.html%23abc)，这里的`#abc`就是hash；
- 散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；
- 监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；
- location.hash值的变化会直接反应到浏览器地址栏；

> 优点

- 只需要前端配置路由表, 不需要后端的参与
- 兼容性好, 浏览器都能支持
- hash值改变不会向后端发送请求, 完全属于前端路由

> 缺点

- hash值前面需要加#, 不符合url规范,也不美观

**history模式**

>  注意：**history 模式**，这种模式充分利用 `history.pushState` API 来完成 URL 跳转而无须重新加载页面。
>
> history.replaceState({}, null, '/b') // 替换路由
> history.pushState({}, null, '/a') // 路由压栈
> history.back() // 返回
> history.forward() // 前进
> history.go(-2) // 后退2次
>
> 前两个浏览器 URL 跳转而无须重新加载页面

`window.history` 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。 History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。



> 优点：

符合url地址规范, 不需要#, 使用起来比较美观

> 缺点：

- 兼容性不如 hash，且需要服务端支持重定向，否则一刷新页面就404了
- 兼容性比较差, 利用了 HTML5 History对象中新增的 pushState() 和 replaceState() 方法,需要特定浏览器的支持.

### 两种模式可以直接上线吗

1. 哈希模式（Hash Mode）：在哈希模式下，路由信息被存储在 URL 的片段标识符（#）后面。这意味着页面的 URL 是不变的，只有片段标识符部分会随着路由的更改而改变。哈希模式对于静态网站或对 SEO 不敏感的应用程序是一种简单有效的路由解决方案，并且在许多前端框架和工具中得到广泛支持。
2. 历史模式（History Mode）：在历史模式下，路由信息通过 HTML5 的 History API 来管理，不再使用片段标识符（#）。这样的路由模式更加直观和符合传统的 URL 结构，对 SEO 也更友好。然而，历史模式需要服务器进行相应的配置，以确保在直接访问或刷新页面时能够正确地返回对应的 HTML 文件，而不会导致 404 错误。


## 虚拟DOM意义？

内容：

```js
{
  tag: 'div',
  props: {
    id: 'app'
  },
  chidren: [
    {
      tag: 'p',
      props: {
        className: 'text'
      },
      chidren: [
        'hello world!!!'
      ]
    }
  ]
}
//el挂载节点信息 标签名称 父元素 子元素
```

历史意义：

在react，vue等技术出现之前：
要改变页面展示的内容，只能通过遍历查询 dom 树的方式找到需要修改的 dom ，
然后修改样式行为或者结构，来达到更新 ui 的目的
**相当消耗计算资源**（每次查询 dom 几乎都需要遍历整颗 dom 树）

优点：

- 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

- 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
- 虚拟 dom运用diff算法来计算出真正需要更新的节点，最大限度地减少DOM操作以及DOM操作带来的排版与重绘损耗，从而显著提高性能
- 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

缺点:

- 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
- 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。

### 引起回流和重绘

回流

1. 添加或者删除可见的 `DOM` 元素；
2. 元素尺寸改变——边距、填充、边框、宽度和高度;
3. 浏览器窗口尺寸改变——resize 事件发生时
4. 计算 offsetWidth 和 offsetHeight 属性

```html
width
height
margin
padding
display
border
position
overflow
clientWidth
clientHeight
clientTop
clientLeft
offsetWidth
offsetHeight
offsetTop
offsetLeft
scrollWidth
scrollHeight
scrollTop
scrollLeft
scrollIntoView()
scrollTo()
getComputedStyle()
getBoundingClientRect()
scrollIntoViewIfNeeded()
```

重绘

```
color
border-style
visibility
background
text-decoration
background-image
background-position
background-repeat
outline-color
outline
outline-style
border-radius
outline-width
box-shadow
background-size
```

优化：[回流和重绘 - 掘金 (juejin.cn)](https://juejin.cn/post/7013187112849637407)

读写分离

样式集中操作

### diff算法

## esModule和commonjs模块化的区别

- 引入方式

  > commonjs是动态导入，可以在代码的任何地方引入
  >
  > esModule模块是静态导入（在编译阶段进行导入），不能动态加载语句，所以import不能写在块级作用域和判断条件内
  >
  > ESM的import命令具有提升效果，会提升到整个模块的头部

- 使用语法

> 使用module.exports导出的是一个模块对象，require()引入的是一个模块对象
>
> 使用export导出指定的数据，import引入具体数据

- 模块导出导入

  > [深入对比esModule和commonjs模块化的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7188173347199385656)
  >
  > 1. 个人理解：commonjs对于基本数据类型，导出的是值的引用，对于复杂数据类型，导出的是值的拷贝
  > 2. esModule导出的一定是值的引用（无论基本数据类型还是引用类型）
  >
  > 
  >
  > esModule模块输出的是一个`值的引用`, 使用的是动态绑定，esModule导入导出的值都指向同一个内存地址，所以导入值会跟着导出值发生变化
  >
  > commonjs模块输出的是一个`值的拷贝`:
  >
  > - 当module.exports的值是数字，字符串等原始类型时，赋值是值的拷贝，这样才会产生导出值的改变不会影响到导入值改变的现象
  > - 如果module.exports导出的是一个对象，导出值的改变是否会影响到导入的值，这个跟导入时赋值的方式是有直接关系的

- 加载运行

> **commonjs**
>
> commonjs是在代码运行时加载，因为commonjs是导出的整个对象，需要在脚本运行完成后才能生成
>
> **esModule**
>
> esModule输出的不是一个对象，它是在静态分析编译时输出接口，它的对外接口只是一种静态的定义，可以理解为生成一个个引用变量，当在模块读取的时候再去取

- 加载模式

> **commonjs**
>
> commonjs使用的是同步加载模块方式，在服务器端大都是读取本地的资源模块，速度非常快，所以采取同步加载方式
>
> **esModule**
>
> esModule使用的是异步加载模块方式，在浏览器端会请求加载网络资源模块，使用同步加载方式会出现卡顿情况

**CommonJs和Es Module的区别**

**CommonJs**

- CommonJs可以动态加载语句，代码发生在运行时
- CommonJs混合导出，还是一种语法，只不过不用声明前面对象而已，当我导出引用对象时之前的导出就被覆盖了
- CommonJs导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染

**Es Module**

- Es Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时
- Es Module混合导出，单个导出，默认导出，完全互不影响
- Es Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改



# 其他

> flex布局讲得比较好[彻底理解CSS Flexbox布局，看这一篇就够了！ - 掘金 (juejin.cn)](https://juejin.cn/post/7004622232378966046)

面试思路：

1. 如果是英文词汇就先翻译成中文
2. 一句话描述该技术的用途
3. 描述该技术的核心概念或运作流程
4. 口述该技术的代码书写思路
5. 该技术的优点
6. 该技术的缺点
7. 如何弥补缺点

## HTTP请求的超时重试机制？添加重试次数呢？

![image-20230904110855593](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230904110855593.png)

```
这个干嘛的？Connection: keep-alive
请求的Authorization字段干嘛的？
```

## 单点登录怎么实现有了解吗？【字节二面】

当时面试官随口提了一句现在我们公司有两个系统，想要在一个系统登录之后另外一个系统也保存用户的登录状态？

[单点登录（SSO）看这一篇就够了-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/636281)

> 总结:
> 同域下的单点登录：利用cookie的domain，设置顶域共享cookie。共享session通过spring session实现
>
> 不同域下单点登录：利用中间人SSO实现，用户在域A下访问app，此时没有登录，跳转到SSO登录系统，SSO没有登录，用户进入SSO登录界面。SSO验证登录之后保存用户的登录状态，写入SSO系统的session，浏览器保存该域下cookie。
>
> SSO生成ST，**传递**并跳转到app，app拿到后向SSO询问ST状态，验证是否OK，OK则生成Session。。。



1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。
2. 跳转到CAS server，即SSO登录系统，**以后图中的CAS Server我们统一叫做SSO系统。** SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

**注意！？**

为何这里要多余子系统向SSO验证ST？

为了避免ST伪造，假如第三方在访问子系统时直接携带非法ST，此时的业务子系统误以为用户登录ok

- **单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。**

# CSS

## 什么是BFC？

Block Formatting Context，即块格式化上下文

[面试官：请说说什么是BFC？大白话讲清楚 - 掘金 (juejin.cn)](https://juejin.cn/post/7208907027841908792)

开启BFC

```css
overflow: hidden
display: inline-block / table-cell / flex / inline-flex

position: absolute / fixed
float：left / right
```

上下在没有添加BFC时，默认会出现外边距塌陷

<img src="https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/44image-20230912095439526.png" alt="image-20230912095439526" style="zoom:25%;" />在不添加浮动的元素上：发现上下部分的外边距塌陷了【左右，上下都是50px】，哪怕添加border也无效

<img src="https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230912100225859.png" alt="image-20230912100225859" style="zoom:25%;" />添加浮动之后，发现左右部分的外边距没有塌陷【上下50px，左右100px】

**简单来说：** BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

> BFC解决的问题

- 使用Float脱离文档流，高度塌陷【清除浮动影响之高度塌陷问题】

```

```



```css
.father{
	overflow:hidden;
}
```

- margin上下边距重合/只有大的有效 问题

为了解决此问题可以使用`BFC`规则（为元素包裹一个盒子形成一个完全独立的空间，做到里面元素不受外面布局影响），或者简单粗暴方法一个设置`margin`，一个设置`padding`。

- 两栏布局：一个浮动，另外一个标准流结果被浮动元素覆盖一部分，解决方案：第二个`div`元素设置为一个`BFC`



## 关于清除浮动

- 给父盒子设置宽高
- 添加元素

```
在父元素内容的最后添加一个块级元素
给添加的块级元素设置 clear:both
```

- 伪元素

```css
  .clearfix::after {
    content: '';
    display: block;
    clear: both;
    /* 补充代码：在网页中看不到伪元素 */
    height: 0;
    visibility: hidden;
  }
```

- 双伪元素

```css
.clearfix:before, .clearfix:after {     
  content:"";    
  display:table;  /* 这句话可以触发 BFC BFC 可以清除浮动 */    
}    
.clearfix:after {    
  clear:both;    
}    
.clearfix {    
  *zoom:1;    
}
```

- 给父元素设置overflow : hidden

- 父元素也浮动

- 

  ```cs
  .father {
      float: left;
  }
  ```

## 垂直水平居中

## 不显示的几种方式

隐藏元素的方法有哪些

- **display: none**：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
- **visibility: hidden**：元素在页面中仍占据空间，但是不会响应绑定的监听事件。
- **opacity: 0**：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
- **position: absolute**：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
- **z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。
- **clip/clip-path** ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
- **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

## 体现自己思考的回答

### http常见请求状态吗？略

### http常见请求方式吗？及区别

[「2021」高频前端面试题汇总之计算机网络篇 - 掘金 (juejin.cn)](https://juejin.cn/post/6908327746473033741)

**GET和POST的请求的区别**

Post 和 Get 是 HTTP 请求的两种方法，其区别如下：

- **应用场景：** GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
- **是否缓存：** 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
- **发送的报文格式：** Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
- **安全性：** Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
- **请求长度：** 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
- **参数类型：** post 的参数传递支持更多的数据类型。

**POST和PUT请求的区别**

- PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**更新数据**）
- POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是**创建数据**）

### http版本发展历史：

| 协议版本    | 支持的请求方式                          | 连接持久性                                                   | 缓存相关                                                     | 相比上个版本新增                                             |
| ----------- | --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **HTTP0.9** | get                                     |                                                              |                                                              |                                                              |
| **HTTP1.0** | GET、HEAD、POST                         | 默认非持久连接，不支持断点续传、 长连接： Connection: Keep-Alive | 强缓存：Expires主要使用 header 里的 If-Modified-Since、Expires 【1.0】来做为缓存判断的标准 默认：默认情况下，浏览器会假定每个响应都可以缓存，并且在后续请求相同资源时会使用缓存的副本。 | 支持响应头，请求头<br />新增协议版本 <br />支持传输纯文本以外的内容 |
| **HTTP1.1** | PUT、OPYIONS,  DELETE, TRACE 和 CONNECT | 默认**持久连接** <br />增加**管线化技术**，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟，解决队头堵塞现象 | 强缓存：Cache-Control http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match，cache-control【1.1**新增**】 等更多可供选择的缓存头来控制缓存策略 浏览器会将**"Cache-Control"设置为"private"**，表示资**源只能被单个用户缓存**，不能在用户之间共享。这是为了保护用户的隐私。 | **新增了 host 字段**，用来指定服务器的域名 还新增了很多**请求方法**，如 PUT、HEAD、OPTIONS 等 支持**断点续传**（响应分块），TCP复用、引入内容协商机制 |
| **HTTP2.0** |                                         | 这是一个**多路复用协议**，解决队头堵塞问题                   |                                                              | HTTP/2 是一个二进制协议，不再是文本协议 数据流、头信息压缩、服务器推送 |
| **HTTP3.0** |                                         | 但在传输层部分使用 [QUIC (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/QUIC) 而不是 [TCP](https://developer.mozilla.org/zh-CN/docs/Glossary/TCP) | HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。 |                                                              |

### HTTP和HTTPS的区别

|                    | HTTP                               | HTTPS                                                        |
| ------------------ | ---------------------------------- | ------------------------------------------------------------ |
| 安全性             | 信息传输类型：明文。超文本传输协议 | 对称加密和非对称加密之后的密文。具有安全性的 SSL 加密传输协议 |
|                    | 不可防护中间人攻击                 | 可防护中间人攻击                                             |
| 端口号：           | 默认80                             | 默认443                                                      |
| 连接类型           | 默认无状态的，不需要身份认证       | HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全 |
| 网站申请流程       | 不需要CA证书                       | 需要CA证书                                                   |
| 网站搜索排名的提升 |                                    | HTTPS网站将会作为搜索排名的一个重要权重指标。也就是说HTTPS网站比起HTTP网站在搜索排名中更有优势 |

为什么说http是无状态的？

> 【字节一面】：无状态的意思是其数据包的发送、传输和接收都是相互独立的。
>
> 无连接的意思是指通信双方都不长久的维持对方的任何信息。

### 计算机网络层级及其协议

2

| 协议                          | OSI 7层参考模型（理论成功，市场失败） | TCP/IP 4层参考模型 | 5层参考模型 |
| ----------------------------- | ------------------------------------- | ------------------ | ----------- |
| HTTP、FTP、SMTP               | 应用层                                | 应用层             |             |
|                               | 表示层                                |                    |             |
|                               | 会话层                                |                    |             |
| TCP/UDP                       | 传输层                                | 传输层             | 传输层      |
| IP/ICMP、RIP、OSPF、BGP、IGMP | 网络层                                | 网际层             | 网络层      |
| PPP、CSMA/CD                  | 数据链路层                            | 网络接口层         | 数据链路层  |
| Rj45                          | 物理层                                |                    | 物理层      |

3

> 补充部分：网络层众多协议，他们的区别是什么？使用场景呢？
>
> - IP
>   IP所提供的服务通常被认为是无连接的和不可靠的，它将差错控制和流量控制之类的服务授权给了其他的各层协议，这正是TCP/IP 能够高效率工作的一个重要保证。网络层的功能主要由IP来提供，除了提供端到端的分组分发功能外，IP还提供很多扩充功能。例如，为了克服数据链路层对帧大小的限制，网络层提供了数据分块和重组功能，这使得很大的IP数据包能以较小的分组在网络上传输。
> - ARP
>   ARP(Address Resolution Protocol，地址解析协议)用于动态地完成IP地址向物理地址的转换。物理地址通常是指计算机的网卡地址，也称为MAC(Medai Access Control，媒体访问控制)地址，每块网卡都有唯一的地址。
> - RARP
>   RARP(Reverse Address Resolution Protocol，反向地址解析协议)用于动态完成物理地址向IP地址的转换。
>
> - ICMP
>   ICMP(Internet Control Message Protocol，网际控制报文协议)是一个专门用于发送差错报文的协议，由于IP协议是一种尽力传送的通信协议，即传送的数据可能丢失、重复、延迟或乱序传递，所以需要一种尽量避免差错并能在发生差错时报告的机制，这就是ICMP的功能。
> - IGMP
>   IGMP(Internet Group Management Protocol，网际组管理协议)允许Internet中的计算机参加多播，是计算机用做向相邻多目路由器报告多组成员的协议。多目路由器是支持组播的路由器，它向本地网络发送IGMP查询，计算机通过发送IGMP报告来应答查询。多目路由器负责将组播包转发到网络中所有组播成员。

作用呢

> IP:用于唯一标识一台主机
>
>  TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：**「ip地址＋协议＋端口号」**唯一标示网络中的一个进程。在一些场合，也把这种唯一标识的模式称为**「套接字 (Socket)」**。

讲解文章：[【计算机网络】分层结构（OSI 7层模型、TCP/TP 4层模型、5层参考模型）_网络分层模型_儒rs的博客-CSDN博客](https://blog.csdn.net/weixin_47750287/article/details/123447035#:~:text=通常，计算机网络会有两个分层模型： 一个是用于学术研究和标准化的7层 OSI模型,（法定标准，缺乏实用性） 另一个是用于实践的4层 TCP%2FIP模型 （事实标准）)

### TCP和UDP的区别

|              | UDP                                                   | TCP                                                   |
| ------------ | ----------------------------------------------------- | ----------------------------------------------------- |
| 是否连接     | 无连接                                                | 面向连接，需要三次握手建立连接                        |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制                  | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制  |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信            | 只能是一对一通信                                      |
| 传输方式     | 面向报文                                              | 面向字节流                                            |
| 首部开销     | 首部开销小，仅8字节                                   | 首部最小20字节，最大60字节                            |
| 适用场景     | 适用于实时应用，例如视频会议、直播、广播通信          | 适用于要求可靠传输的应用，例如文件传输                |
| 性能瓶颈     | 应用程序生成数据的速度、 计算机的能力、传输带宽的限制 | 除了UDP的限制比如带宽、计算机性能之外还有拥塞控制算法 |

> TCP可靠交付是如何实现的？有哪些保证可靠交付的算法？这些算法的应用场景？
>
> 可靠交付实现途径
>
> - 检验和
>
> - 序列号/确认应答
>
> - 超时重传：根据SRTT（平滑往返时间Round Trip Time）
>
> - 最大消息长度：TCP连接建立时，约定MSS
>
> - 滑动窗口控制【又名流量控制】：发送方和接受方维护一个发送窗口和接受窗口。
>
> - 拥塞控制：
>
> 
>
>
> 1. 滑动窗口：
> 2. 超时重传
> 3. 流量控制
> 4. 拥塞控制

发送窗口分为4部分：

- \#1 已发送，并得到接收方 ACK 确认；
- \#2 已发送，但还未收到接收方 ACK；
- \#3 未发送，但接收方允许发送，接收方还有空间
- \#4 未发送，且接收方不允许发送，接收方没有空间

接受窗口分为3部分：

- 已接收已确认；
- 未接收，准备接收；
- 未接收，并未准备接收；

[（一）TCP 端口 · 理解 TCP 和 UDP (gitbooks.io)](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/content/chapter1.html)







### 前段跨域解决方案

|               | 开发环境 | 生产环境  |
| ------------- | -------- | --------- |
| proxy配置代理 | 直接配置 | 不可      |
| jsonp         |          | 可以解决* |
| cors          |          |           |
| nginx反向代理 |          |           |

为什么jsonp？

### ESmodle和commonJS区别

|          | commonJS                           | ESmodle                                      |
| -------- | ---------------------------------- | -------------------------------------------- |
| 引入     | 动态导入，在执行的任何阶段都可导入 | 静态导入，只允许编译阶段导入，不允许动态加载 |
| 导出     | 模块对象                           | 具体数据                                     |
|          | 简单：值拷贝；复杂：值引用         | 都是值的引用                                 |
| 加载模式 | 同步加载，运行时加载               | 异步加载，静态编译                           |

### js闭包的应用场景及好处

> 优点：

- 保护函数内的变量安全，限制外部访问，实现数据的私有
- 在内存中维持一个变量，可以做缓存

> 缺点：

- 可能会常驻内存，造成内存泄漏

> 场景：

- 根据优点：变量私有化
- 匿名自执行函数
- 实现类和继承

### 虚拟DOM好处

> 优点

- 无需手动操作 DOM
- 跨平台
- 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的

> 缺点

- 法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
- 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。

### Vue2和Vue3的区别

|                | Vue2                  | Vue3                           |
| -------------- | --------------------- | ------------------------------ |
| 响应式原理基础 | Object.defineProperty | proxy                          |
| 生命周期       |                       |                                |
| 组合式API      |                       |                                |
| 虚拟DOM        |                       | 节点新增patchFlag              |
| diff算法       |                       | 根据虚拟DOM的patchFlag修改进度 |
| 多根节点       | 否                    | 是                             |
|                |                       |                                |

### Token与Cookie、Session的区别

|          | Token                                                        | Cookie                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 作用     | 兼容性好，支持移动端                                         | 不支持移动端                                                 |
| 主要内用 | cookie的出现本身是为了解决http请求无状态的问题               | sessionID                                                    |
| 出现原因 | session问题；<br />解决负载均衡时不同机器sessionId不统一的问题，哪怕nginx做黏连，机器依旧可能挂掉<br />解决redis的session共享性能消耗问题 |                                                              |
| 存放位置 | 请求头的Authorization                                        | 请求头的cookie。浏览器内存【会话cookie】/硬盘                |
| 缺点     |                                                              | 不可跨域支持<br />兼容性：对于不支持cookie的移动端，兼容性不好<br />安全：历史遗留问题，存在默认存储以及默认发送问题，有安全性问题可能存在csrf攻击<br />空间：只允许存储4k |
| 场景     | 单点登录                                                     |                                                              |

为什么有了cookie还要存在token？

[面试官：说说 Cookie 和 Token 的区别？ - 掘金 (juejin.cn)](https://juejin.cn/post/7111349594625146887)

cookie和session区别

|            | cookie                                                       | session                                                      |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储位置   | 本地                                                         | 服务器                                                       |
| 容量       | <=4kb                                                        | 理论上无限制                                                 |
| 有效期     | 可以长期存储，只要不超过设置的过期时间，可以一直存储         | 超过一定的操作时间(通常为30分钟)后会失效，但是当关闭浏览器时 |
| 安全性     | 存储在客户端，所以可以分析存放在本地的cookie并进行cookie欺骗，安全性较低 | 存储在服务器上，不存在敏感信息泄漏的风险，安全性较高         |
| 域支持范围 | 支持跨域名访问。例如，所有www.a.com的cookie在a.com下都能用   | 不支持跨域名访问。例如，www.a.com的session在api.a.com下不能用 |
| 域支持范围 | 保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据 | 存储任何类型的数据，包括且不限于string，integer，list，map等 |
|            |                                                              |                                                              |

补充cookie的一些属性：

| 属性名  | 属性说明                                                     |
| ------- | ------------------------------------------------------------ |
| maxAge  | Cookie有效期，单位秒。如果为整数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为-1 |
| Expires | Cookie的失效时间，如果Cookie没有设置过期时间，那么 cookie 的生命周期只是在当前的会话中，关闭浏览器意味着这次会话的结束，此时 cookie 随之失效， 现在已经被maxAge属性所取代 |
| secure  | 它是一个布尔值，指定在网络上如何传输Cookie，默认为false，通过一个普通的http连接传输，标记为true的Cookie只应通过被 HTTPS 协议加密过的请求发送给服务端 |
| path    | Cookie的使用路径,path标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）, 例如：如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie，如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/” |
| domain  | **只能设置当前域及父域**                                     |



关于浏览器关闭时候session是否存在：[浏览器关闭后Session真的消失了吗？-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1511944)

### 了解cdn吗？【字节】

[面试官：如何理解CDN？说说实现原理？ | web前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/http/CDN.html#一、是什么)

> `CDN`就是根据用户位置分配最近的资源

### 详细讲一下vue-router

那两种模式？



如何实现的？

为何history模式兼容性差？

为什么要使用dom原生api实现？

### 单页面应用加尔多页面应用的区别

#### 单页应用与多页应用的区别

|                 | 单页面应用（SPA）         | 多页面应用（MPA）                   |
| :-------------- | :------------------------ | :---------------------------------- |
| 组成            | 一个主页面和多个页面片段  | 多个主页面                          |
| 刷新方式        | 局部刷新                  | 整页刷新                            |
| url模式         | 哈希模式                  | 历史模式                            |
| SEO搜索引擎优化 | 难实现，可使用SSR方式改善 | 容易实现                            |
| 数据传递        | 容易                      | 通过url、cookie、localStorage等传递 |
| 页面切换        | 速度快，用户体验良好      | 切换加载资源，速度慢，用户体验差    |
| 维护成本        | 相对容易                  | 相对复杂                            |

**单页应用优缺点)单页应用优缺点**

优点：

- 具有桌面应用的即时性、网站的可移植性和可访问性
- 用户体验好、快，内容的改变不需要重新加载整个页面
- 良好的前后端分离，分工更明确

缺点：

- 不利于搜索引擎的抓取
- 首次渲染速度相对较慢

## 正则表达式

[JS正则表达式完整教程（略长） - 掘金 (juejin.cn)](https://juejin.cn/post/6844903487155732494)

# 项目相关

## 遇到过那个问题？花费你的时间最久？

**一个3级组件通信+echarts使用问题：**

首次页面加载时，echarts图像没有初始化。打开开发者工具查看，子组件明明数据已经有了。

原因：echarts的数据是通过父组件在mounted生命周期发起http请求拿到的，但是。此时场景，由于组件挂载顺序是子组件先于父组件挂载，此时子组件拿不到父组件在mounted里面拿到的数据理所当然。

但是，当我修改生命周期为created之后还是不行。后来反思了下原因由于异步任务导致的。

最终解决：让父组件拿到数据之后子组件才挂载，首次渲染问题解决



新问题：父组件修改状态：比如修改学生类型是研究生，图表没有刷新，或者刷新后图表又消失了

添加watch监听之后呢？





**你觉得项目中你做的最大亮点是什么？**

原有的权限管理的方案是基于角色的权限控制，即RBAC0方案，用户的权限通过角色进行打包。

但是，随着业务推进，提出新的需求，要求用户切换项目时，对不同项目有不同的权限。

**问题：**

- 用户在不同项目中权限是一样的。
- 权限控制只能控制到角色，所有权限都是和角色打包存在的，无法实现用户与角色的部分解耦。比如说有一个场景，用户A我分配了一个临时的项目负责人，但是我不想让这个项目负责人能够操作其他项目负责人的权限，比如为项目添加成员，原有RBAC如何控制呢？RBAC0和RBAC1只能新增一个角色，然后控制这个角色其他和项目负责人一样，唯独缺少了添加项目成员权限。RBAC2，同样如此，添加一个互斥的角色，让用户的项目权限取项目负责人和这个互斥角色的差集。

面对这个问题：由于RBAC权限控制方案是不可能控制到具体的某个项目的，因为RBAC就是用户-角色-权限，为此，我们需要实现（用户-项目） - 项目角色 - 权限。

这样即保留了RBAC方案的角色打包权限的优点，同时结合了DAC（自主访问控制的灵活）



这个在项目中的体现就是：用户可以在项目中分配项目角色，然后打包这个角色对应的项目权限，同时可以在原有项目角色权限上直接添加或者删除某个具体的权限。

**市场上权限管理的控制方案？**





**如何控制用户的只读权限呢？**

在用户-项目-权限表字段包括uid，pid，permissionids，methods【缺省则表示所有请求方式都允许，不缺省则控制对应方法的权限】，

比如获取需求清单数据（读权限），这个在项目里面直接通过新增一个权限字符实现，

修改怎么办？新增修改需求权限

保留原有的系统权限，让系统权限能够控制只是路由菜单，具体的读写权限由项目权限接手。







# 美团二面准备



宏任务/微任务补充：

- setTimeout setInterval —— 宏任务
- promise 和 async/await  —— 微任务
- process.nextTick —— 微任务，**但优先级最高**
- setImmediate —— 宏任务
- I/O 文件、网络 —— 宏任务
- Socket 连接：连接 mysql —— 宏任务

这里注意浏览器和node环境setTimeout 和setImmediate 优先级不一样，在node12版本setImmediate > setTimeout 

![image-20230919105001679](https://s1.vika.cn/space/2023/09/19/12a03bc1173f40d688b5e26f84b9d3c8)

![image-20230919105018057](https://s1.vika.cn/space/2023/09/19/2acc9fbe85c94354b23bec3cafb5f013)



平台技术部，一面全是八股和一些基础，加上一道Medium手撕题重拍链表

二面历时1h的虐杀，心态全崩，我到底是什么菜狗

自我介绍
什么时候接触前端，为什么选择前端，怎么学习前端
学习前端中比较有挑战的问题
目前秋招进度怎么样，有几个offer
对base的偏好

再说说项目中还有什么亮点
研究生期间的研究方向
vue2数据响应式原理
template怎么捕获依赖（开始懵逼）![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)
vue的渲染流程（答的虚拟dom挂载啥的感觉不对）![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)

vue2和vue3生命周期的区别
diff算法
webpack能做什么，工作流程
loader和plugin的区别
loader和plugin在什么阶段发挥作用 ![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)
webpack打包后的文件结构![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)

了解哪些模块化规则，es6和commonJS，有啥区别 ![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\@6U%1QUEL[`FM$N1LKQUZTL.png)
es6为什么适合浏览器，commonJS适合nodejs ![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)

异步引入模块怎么保证不出错（这说了很久，一直返回问这个但是我真的没明白要问我啥）![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png) 

【这里开始大脑彻底宕机，战或逃激素使劲儿让我逃】
浏览器事件循环和nodeJS事件循环的区别（只答了浏览器事件循环）![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)

事件循环题 ![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)

var b = "b";
setTimeout(function(){
		import("./a.js").then(res=>{
				console.log(res,"1s")
		})
},1000)
setTimeout(function(){
		console.log("500ms")
},500)

最后手写并发请求控制 ![img](file:///C:\Users\hang\AppData\Roaming\Tencent\QQTempSys\P4P[MSA1(J2ZBDY29MI0(%O.png)

最后心态已经崩了，直接说感觉我的能力和岗位不符合，感谢面试官时间

问了一些学习建议灰溜溜的滚蛋了，webpack咋学啊就会点基础配置啊啊啊啊啊救命啊

面的想死

二面面试官是不是强者发型

看着还行啊 感觉挺茂密的

# CSS自己整理

参考：[「2021」高频前端面试题汇总之CSS篇 - 掘金 (juejin.cn)](https://juejin.cn/post/6905539198107942919#heading-6)

## 实现元素隐藏的几种方法？区别

|                           | 是否占用位置 | 绑定的回调函数是否执行 |
| ------------------------- | ------------ | ---------------------- |
| **display:none**          | 不占用       | 不会响应               |
| **visibility: hidden**    | 占用         | 不会响应               |
| **opacity: 0**            | 占用         | 会响应                 |
| **transform: scale(0,0)** | 仍然占用     | 不会                   |
| **z-index: 负值**         |              |                        |
| **position: absolute**    |              |                        |
| **clip/clip-path**        |              |                        |



|       | nums | ans             |
| ----- | ---- | --------------- |
| index | 0    | （0+k）%len = 3 |
|       | 1    | 1               |
|       | 3    | 6 % 7 = 6       |
|       | 5-6  | 8 % 7 = 1       |



# 面试现场手撕部分

![image-20230913154826413](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230913154826413.png)

答案2/3

![image-20230913154838321](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230913154838321.png)

![image-20230913154851310](https://cdn.staticaly.com/gh/hangvlog/PICGO_ImgBed@main/2023/4image-20230913154851310.png)





https://ssosv.it.test.sankuai.com/sson/login?client_id=e673d47d22&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fsso%2Fcallback%3Foriginal-url%3D%252F&state=u8qmefd8fs&code_challenge=d7lPJNsz%2BJER%2FWpv0jjTfcgdTa2lT2aX6ZjJZPXrH%2Fo%3D&code_challenge_method=SHA256&locale=zh



假如勾选灰度发布但是没有规则开启 那么发布的是主干



假如勾选了灰度发布，而且开启了灰度规则，那么灰度规则会生效 

然后关掉所有灰度规则，那么所有人访问的就再次成了改代码之前的样子【就是成了主干】

【这样会不会导致灰度的覆盖？？】

> 假如存在这样的情况，就是先勾选了灰度规则A，然后发布。表示这批用户不同于其他用户。然后公司的测试成员要测试，于是再次灰度发布，灰度策略进行添加B并打开（此时灰度规则A依旧处于打开状态），那么此时在B内的成员是最新的，那么之前满足A的用户呢（假如A的用户不满足B的规则）？

新的场景，假如我发布了灰度，并且规则打开。然后规则保持打开，小组其他成员再次发布，那么？



据此推断

```javascript
//用户访问时
if (开启了某个灰度规则){
  满足灰度规则的用户访问的是灰度内容
  不满足灰度规则的用户访问的是主干内容
}else{
  主干内容
}
```

```javascript
//代码发布时
if (开启了某个灰度规则){
  更新灰度版本内容
}else{
  更新主干内容
}
```

http://localhost:8000/questionAnswering/index?protocol=http
